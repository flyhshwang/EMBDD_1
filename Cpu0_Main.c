/**********************************************************************************************************************
 * \file Cpu0_Main.c
 * \copyright Copyright (C) Infineon Technologies AG 2019
 * 
 * Use of this file is subject to the terms of use agreed between (i) you or the company in which ordinary course of 
 * business you are acting and (ii) Infineon Technologies AG or its licensees. If and as long as no such terms of use
 * are agreed, use of this file is subject to following:
 * 
 * Boost Software License - Version 1.0 - August 17th, 2003
 * 
 * Permission is hereby granted, free of charge, to any person or organization obtaining a copy of the software and 
 * accompanying documentation covered by this license (the "Software") to use, reproduce, display, distribute, execute,
 * and transmit the Software, and to prepare derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:
 * 
 * The copyright notices in the Software and this entire statement, including the above license grant, this restriction
 * and the following disclaimer, must be included in all copies of the Software, in whole or in part, and all 
 * derivative works of the Software, unless such copies or derivative works are solely in the form of 
 * machine-executable object code generated by a source language processor.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE 
 * COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN 
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS 
 * IN THE SOFTWARE.
 *********************************************************************************************************************/
#include "Ifx_Types.h"
#include "IfxCpu.h"
#include "IfxScuWdt.h"

// 단색LED
// RED     D12  : Port10 Pin1
// BLUE    D13  : Port10 Pin2

// p. 3-14~15
// Table 3-3 On Chip Bus Address Map of Segment 15
// PORT02 | F003A200 - F003A2FF | ---> PORT2_BASE
// PORT10 | F003B000 - F003B0FF | ---> PORT10_BASE

//3색LED작동

// RED    D9    : Port2  Pin7 TOUT7  TOUTSEL0 SEL7    TOM0_15
// GREEN  D10   : Port10 Pin5 TOUT107 TOUTSEL6 SEL11  TOM0_2
// BLUE   D11   : Port10 Pin3 TOUT105 TOUTSEL6 SEL9   TOM0_3


#define PORT2_BASE     (0xF003A200)
#define PORT10_BASE    (0xF003B000)

// register   | offset  ---> p13-102 / Table13-17
//Pn_IOCR0    | 0010h
//Pn_IOCR4    | 0014h
//Pn_OMR      | 0004h
//Pn_IN       | 0024h

#define PORT2_IOCR0   (*(volatile unsigned int*)(PORT2_BASE + 0x10))
#define PORT2_IOCR4   (*(volatile unsigned int*)(PORT2_BASE + 0x14))
#define PORT2_OMR     (*(volatile unsigned int*)(PORT2_BASE + 0x04))
#define PORT2_IN      (*(volatile unsigned int*)(PORT2_BASE + 0x24))


#define PORT10_IOCR0   (*(volatile unsigned int*)(PORT10_BASE + 0x10))
#define PORT10_IOCR4   (*(volatile unsigned int*)(PORT10_BASE + 0x14))
#define PORT10_OMR     (*(volatile unsigned int*)(PORT10_BASE + 0x04))


//Pn_IOCR0 register p.13-15
// 31       27 26  24 23      19  18     16
//+-----------+------+----------+---------+
//|  PC3      | 0    |    PC2   |    0    |
//+-----------+------+----------+---------+

// 15       11 10   8 7        3 2       0
//+-----------+------+----------+---------+
//|  PC1      | 0    |    PC0   |    0    |
//+-----------+------+----------+---------+


//Pn_IOCR4 register p.13-17
// 31       27 26  24 23      19  18     16
//+-----------+------+----------+---------+
//|  PC7      | 0    |    PC6   |    0    |
//+-----------+------+----------+---------+

// 15       11 10   8 7        3 2       0
//+-----------+------+----------+---------+
//|  PC5      | 0    |    PC4   |    0    |
//+-----------+------+----------+---------+

// IOCRX register offset
#define PC0      3
#define PC1     11
#define PC2     19
#define PC3     27
#define PC5     11
#define PC7     27


//OMR PIN 3, 5, 7 register ---> p.13-39
// 31  30  29  28  27  26  25  24  23  22  21  20  19  18  17  16
//+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//|PCL|PCL|PCL|PCL|PCL|PCL|PCL|PCL|PCL|PCL|PCL|PCL|PCL|PCL|PCL|PCL|
//| 15| 14| 13| 12| 11| 10|  9|  8|  7|  6|  5|  4|  3|  2|  1|  0|
//+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//
//  15  14  13  12  11  10  9   8   7   6   5   4   3   2   1   0
//+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//| PS| PS| PS| PS| PS| PS| PS| PS| PS| PS| PS| PS| PS| PS| PS| PS|
//| 15| 14| 13| 12| 11| 10|  9|  8|  7|  6|  5|  4|  3|  2|  1|  0|
//+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+

//단색 LED
#define PCL1   17
#define PCL2   18

#define PS1    1
#define PS2    2

#define PCL3   19
#define PCL5   21
#define PCL7   23

#define PS3    3
#define PS5    5
#define PS7    7



// Initialize LED (RED&BLUE)
void init_LED(void)
{
    //Reset PC1 & PC2 in IOCR0
    PORT10_IOCR0 &= ~((0x1F) << PC1);
    //PORT10_IOCR0 &= ~((0x1F) << PC2);

    //Set PC1 & PC2 (2b10001) : p.13-25 Table 13-5

    PORT10_IOCR0 |= ((0x11) << PC1);  //PORT10.1 : Alternate output function 1 (push-pull)
    //PORT10_IOCR0 |= ((0x11) << PC2);  //PORT10.1 : GTM_TOUT103

}

// Initialize LED (RED&BLUE)
void init_RGBLED(void)
{
    //Reset PC1 & PC2 in IOCR0 0x1F = 11111
    PORT2_IOCR4  &= ~((0x1F) << PC7);
    PORT10_IOCR4 &= ~((0x1F) << PC5);
    PORT10_IOCR0 &= ~((0x1F) << PC3);

    //Set PC1 & PC2 with push pull(2b10000) : p.13-25 Table 13-5
    //PCx | 10000 --> 10h | Push-Pull | General-purpose output

    PORT2_IOCR4  |= ((0x11) << PC7);
    PORT10_IOCR4 |= ((0x11) << PC5);
    PORT10_IOCR0 |= ((0x11) << PC3);


}


 //SCU Register  p.7-311
 // | MODULE      | BASE ADDRESS  | END ADDRESS |
 // |   SCU       |   F0036000    |   F00363FF  |
 //Offset
 // | Name        |  Offset Addr  | Description
 // | WDTCPU0CON0 | 100           | 7-276
 // “CE0”- writeable only when CPU0 ENDINIT bit is zero
 // “CE1” - writeable only when CPU1 ENDINIT bit is zero
 // “CE2” - writeable only when CPU2 ENDINIT bit is zero
 // “E” - writeable when any (one or more) CPUx ENDINIT bit is zero
 // “SE” - writeable only when Safety ENDINIT bit is zero
 // None of the above - accessible at any time


 #define SCU_BASE      (0xF0036000) // p.7-311 Table 7-27
 #define SCU_WDTCPU0CON0  (*(volatile unsigned int*)(SCU_BASE + 0x100))

 #define LCK           1
 #define ENDINIT       0


 //Potentiometer
 //SAR4_7 AD0 | A0 D14

 //VADC Registers p.28-148
 // | MODULE      | BASE ADDRESS  | END ADDRESS |
 // |   VADC      |   F0020000    |   F0023FFF  |
 //Offset
 // | Name        |  Offset Addr  | Description
 // | CLC         | 0000          | 28-15
 // | GLOBCFG     | 0080          | 28-23
 // | GXARBCFG    | X*0400 +0480  | 28-68
 // | G4ARBCFG    | 1480          | 28-68
 // | GXARBPR     | X*0400 +0484  | 28-71
 // | G4ARBPR     | 1484          | 28-71
 // | GXICLASS0   | X*0400 +04A0  | 28-78
 // | G4ICLASS0   | 14A0          | 28-78
 // | GXQMR0      | X*0400 +0504  | 28-40
 // | G4QMR0      | 1504          | 28-40
 // | GXQINR0     | X*0400 +0510  | 28-44
 // | G4QINR0     | 1510          | 28-44
 // | GXCHCTRy    | X*0400 +060Y  | 28-75
 // | G4CHCTR7    | 161C          | 28-75
 // | GXRESy      | X*0400 +070Y  | 28-98
 // | G4RES1      | 1704          | 28-98
 // | G4RES3      | 170C          | 28-98

 #define VADC_BASE      (0xF0020000)
 #define VADC_CLC       (*(volatile unsigned int*)(VADC_BASE + 0x0000))
 #define VADC_GLOBCFG   (*(volatile unsigned int*)(VADC_BASE + 0x0080))
 #define VADC_G4ARBCFG  (*(volatile unsigned int*)(VADC_BASE + 0x1480))
 #define VADC_G4ARBPR   (*(volatile unsigned int*)(VADC_BASE + 0x1484))
 #define VADC_G4ICLASS0 (*(volatile unsigned int*)(VADC_BASE + 0x14A0))
 #define VADC_G4QMR0    (*(volatile unsigned int*)(VADC_BASE + 0x1504))
 #define VADC_G4QINR0   (*(volatile unsigned int*)(VADC_BASE + 0x1510))
 #define VADC_G4CHCTR7  (*(volatile unsigned int*)(VADC_BASE + 0x161C))
 #define VADC_G4RES1    (*(volatile unsigned int*)(VADC_BASE + 0x1704))
 #define VADC_G4RES3    (*(volatile unsigned int*)(VADC_BASE + 0x170C))

 #define DISS           1
 #define DISR           0
 #define ANONC          0
 #define ASEN0          24
 #define CSM0           3
 #define PRIO0          0
 #define CMS            8
 #define STCS           0
 #define FLUSH          10
 #define TREV           9
 #define ENGT           0
 #define RF             5
 #define REQCHNR        0
 #define RESPOS         21
 #define RESREG         16
 #define ICLSEL         0
 #define VF             31
 #define RESULT         0

// GTM Registers
// GTM Registers p.25-742
// | MODULE      | BASE ADDRESS  | END ADDRESS |
// |   GTM       |   F0100000    |   F019FFFF  |
//Offset
// | Name        |  Offset Addr  | Description
// | CLC         | 9FD00         | 25-749


// GTM
#define GTM_BASE          (0xF0100000)
#define GTM_CMU_CLK_EN     (*(volatile unsigned int*)(GTM_BASE + 0x300))
#define GTM_CMU_FXCLK_CTRL (*(volatile unsigned int*)(GTM_BASE + 0x344))
#define GTM_CLC            (*(volatile unsigned int*)(GTM_BASE + 0x9FD00))
#define GTM_TOUTSEL0       (*(volatile unsigned int*)(GTM_BASE + 0x9FD30))
#define GTM_TOUTSEL6       (*(volatile unsigned int*)(GTM_BASE + 0x9FD48))

#define DISS               1
#define DISR               0


#define EN_FXCLK           22
#define FXCLK_SEL          0
#define SEL7               14 // tout103 tout7
#define SEL8               16 // tout104
#define SEL9               18 // tout105
#define SEL11               22 // tout107


// RED    D9    : Port2  Pin7 TOUT7  TOUTSEL0 SEL7    TOM0_15
// GREEN  D10   : Port10 Pin5 TOUT107 TOUTSEL6 SEL11  TOM0_2
// BLUE   D11   : Port10 Pin3 TOUT105 TOUTSEL6 SEL9   TOM0_3

 // GTM - TOM0
#define GTM_TOM0_TGC0_GLB_CTRL         (*(volatile unsigned int*)(GTM_BASE + 0x08030))
#define GTM_TOM0_TGC0_ENDIS_CTRL       (*(volatile unsigned int*)(GTM_BASE + 0x08070))
#define GTM_TOM0_TGC0_OUTEN_CTRL       (*(volatile unsigned int*)(GTM_BASE + 0x08078))
#define GTM_TOM0_TGC0_FUPD_CTRL        (*(volatile unsigned int*)(GTM_BASE + 0x08038))
#define GTM_TOM0_TGC1_GLB_CTRL         (*(volatile unsigned int*)(GTM_BASE + 0x08230))
#define GTM_TOM0_TGC1_ENDIS_CTRL       (*(volatile unsigned int*)(GTM_BASE + 0x08270))
#define GTM_TOM0_TGC1_OUTEN_CTRL       (*(volatile unsigned int*)(GTM_BASE + 0x08278))
#define GTM_TOM0_TGC1_FUPD_CTRL        (*(volatile unsigned int*)(GTM_BASE + 0x08238))
//TOUT103
#define GTM_TOM0_CH1_CTRL              (*(volatile unsigned int*)(GTM_BASE + 0x08040))
#define GTM_TOM0_CH1_SR0               (*(volatile unsigned int*)(GTM_BASE + 0x08044))
#define GTM_TOM0_CH1_SR1               (*(volatile unsigned int*)(GTM_BASE + 0x08048))
//TOUT104 T107
#define GTM_TOM0_CH2_CTRL              (*(volatile unsigned int*)(GTM_BASE + 0x08080))
#define GTM_TOM0_CH2_SR0               (*(volatile unsigned int*)(GTM_BASE + 0x08084))
#define GTM_TOM0_CH2_SR1               (*(volatile unsigned int*)(GTM_BASE + 0x08088))
//TOUT104 T105
#define GTM_TOM0_CH3_CTRL              (*(volatile unsigned int*)(GTM_BASE + 0x080C0))
#define GTM_TOM0_CH3_SR0               (*(volatile unsigned int*)(GTM_BASE + 0x080C4))
#define GTM_TOM0_CH3_SR1               (*(volatile unsigned int*)(GTM_BASE + 0x080C8))
//TOUT7
#define GTM_TOM0_CH15_CTRL              (*(volatile unsigned int*)(GTM_BASE + 0x083C0))
#define GTM_TOM0_CH15_SR0               (*(volatile unsigned int*)(GTM_BASE + 0x083C4))
#define GTM_TOM0_CH15_SR1               (*(volatile unsigned int*)(GTM_BASE + 0x083C8))


#define UPEN_CTRL1               18
#define UPEN_CTRL2               20
#define UPEN_CTRL3               22
#define UPEN_CTRL7               30
#define HOST_TRIG                0
#define ENDIS_CTRL1               2
#define ENDIS_CTRL2               4
#define ENDIS_CTRL3               6
#define ENDIS_CTRL7               14
#define OUTEN_CTRL1               2
#define OUTEN_CTRL2               4
#define OUTEN_CTRL3               6
#define OUTEN_CTRL7               14
#define RSTCN0_CH1               18
#define RSTCN0_CH2               20
#define RSTCN0_CH3               22
#define RSTCN0_CH7               30
#define FUPD_CTRL1                2
#define FUPD_CTRL2                4
#define FUPD_CTRL3                6
#define FUPD_CTRL7               14
#define CLK_SRC_SR               12
#define SL                       11



 void init_GTM_TOM0_PWM(void)
 {
     /* GTM Enable */
     /* Password Access to unlock WDTCPU0CON0 */
     SCU_WDTCPU0CON0 = ((SCU_WDTCPU0CON0 ^ 0xFC) & ~(1 << LCK)) | (1 << ENDINIT);
     while((SCU_WDTCPU0CON0 & (1<< LCK)) != 0);

     // Modify Aceess to clear ENDINIT bit
     SCU_WDTCPU0CON0 = ((SCU_WDTCPU0CON0 ^ 0xFC) | (1 << LCK)) & ~ (1 << ENDINIT);
     while((SCU_WDTCPU0CON0 &(1 << LCK)) == 0);

     GTM_CLC &= ~(1 << DISR);     // Enable VADC Module

     /* Password Access to unlock WDTCPU0CON0 */
     SCU_WDTCPU0CON0 = ((SCU_WDTCPU0CON0 ^ 0xFC) & ~(1 << LCK)) | (1 << ENDINIT);
     while((SCU_WDTCPU0CON0 & (1<< LCK)) != 0);

     // Modify Aceess to set ENDINIT bit
     SCU_WDTCPU0CON0 = ((SCU_WDTCPU0CON0 ^ 0xFC) | (1 << LCK)) | (1 << ENDINIT);
     while((SCU_WDTCPU0CON0 &(1 << LCK)) == 0);

     while((GTM_CLC & (1<<DISS)) !=0);      //Wait until module is enabled

     // GTM CLOCK SETTING
     GTM_CMU_FXCLK_CTRL &=~((0xF)<< FXCLK_SEL);

     GTM_CMU_CLK_EN &= ~((0x3)<<EN_FXCLK);
     GTM_CMU_CLK_EN |= ((0x2)<<EN_FXCLK);

     //GTM_TOM0 PWM SETTING
     GTM_TOM0_TGC0_GLB_CTRL &=~((0x3)<< UPEN_CTRL1);
     GTM_TOM0_TGC0_GLB_CTRL |= ((0x2)<< UPEN_CTRL1);
     GTM_TOM0_TGC0_GLB_CTRL &=~((0x3)<< UPEN_CTRL2);
     GTM_TOM0_TGC0_GLB_CTRL |= ((0x2)<< UPEN_CTRL2);
     GTM_TOM0_TGC0_GLB_CTRL &=~((0x3)<< UPEN_CTRL3);
     GTM_TOM0_TGC0_GLB_CTRL |= ((0x2)<< UPEN_CTRL3);
     GTM_TOM0_TGC1_GLB_CTRL &=~((0x3)<< UPEN_CTRL7);
     GTM_TOM0_TGC1_GLB_CTRL |= ((0x2)<< UPEN_CTRL7);


     GTM_TOM0_TGC0_FUPD_CTRL &=~((0x3)<< FUPD_CTRL1);
     GTM_TOM0_TGC0_FUPD_CTRL |= ((0x2)<< FUPD_CTRL1);
     GTM_TOM0_TGC0_FUPD_CTRL &=~((0x3)<< FUPD_CTRL2);
     GTM_TOM0_TGC0_FUPD_CTRL |= ((0x2)<< FUPD_CTRL2);
     GTM_TOM0_TGC0_FUPD_CTRL &=~((0x3)<< FUPD_CTRL3);
     GTM_TOM0_TGC0_FUPD_CTRL |= ((0x2)<< FUPD_CTRL3);
     GTM_TOM0_TGC1_FUPD_CTRL &=~((0x3)<< FUPD_CTRL7);
     GTM_TOM0_TGC1_FUPD_CTRL |= ((0x2)<< FUPD_CTRL7);
     GTM_TOM0_TGC0_FUPD_CTRL &=~((0x3)<< RSTCN0_CH1);
     GTM_TOM0_TGC0_FUPD_CTRL |= ((0x2)<< RSTCN0_CH1);
     GTM_TOM0_TGC0_FUPD_CTRL &=~((0x3)<< RSTCN0_CH2);
     GTM_TOM0_TGC0_FUPD_CTRL |= ((0x2)<< RSTCN0_CH2);
     GTM_TOM0_TGC0_FUPD_CTRL &=~((0x3)<< RSTCN0_CH3);
     GTM_TOM0_TGC0_FUPD_CTRL |= ((0x2)<< RSTCN0_CH3);
     GTM_TOM0_TGC1_FUPD_CTRL &=~((0x3)<< RSTCN0_CH7);
     GTM_TOM0_TGC1_FUPD_CTRL |= ((0x2)<< RSTCN0_CH7);

     GTM_TOM0_TGC0_ENDIS_CTRL &=~((0x3)<< ENDIS_CTRL1);
     GTM_TOM0_TGC0_ENDIS_CTRL |= ((0x2)<< ENDIS_CTRL1);
     GTM_TOM0_TGC0_ENDIS_CTRL &=~((0x3)<< ENDIS_CTRL2);
     GTM_TOM0_TGC0_ENDIS_CTRL |= ((0x2)<< ENDIS_CTRL2);
     GTM_TOM0_TGC0_ENDIS_CTRL &=~((0x3)<< ENDIS_CTRL3);
     GTM_TOM0_TGC0_ENDIS_CTRL |= ((0x2)<< ENDIS_CTRL3);
     GTM_TOM0_TGC1_ENDIS_CTRL &=~((0x3)<< ENDIS_CTRL7);
     GTM_TOM0_TGC1_ENDIS_CTRL |= ((0x2)<< ENDIS_CTRL7);
     GTM_TOM0_TGC0_OUTEN_CTRL &=~((0x3)<< OUTEN_CTRL1);
     GTM_TOM0_TGC0_OUTEN_CTRL |= ((0x2)<< OUTEN_CTRL1);
     GTM_TOM0_TGC0_OUTEN_CTRL &=~((0x3)<< OUTEN_CTRL2);
     GTM_TOM0_TGC0_OUTEN_CTRL |= ((0x2)<< OUTEN_CTRL2);
     GTM_TOM0_TGC0_OUTEN_CTRL &=~((0x3)<< OUTEN_CTRL3);
     GTM_TOM0_TGC0_OUTEN_CTRL |= ((0x2)<< OUTEN_CTRL3);
     GTM_TOM0_TGC1_OUTEN_CTRL &=~((0x3)<< OUTEN_CTRL7);
     GTM_TOM0_TGC1_OUTEN_CTRL |= ((0x2)<< OUTEN_CTRL7);

     GTM_TOM0_CH1_CTRL |= (1<<SL);
     GTM_TOM0_CH2_CTRL |= (1<<SL);
     GTM_TOM0_CH3_CTRL |= (1<<SL);
     GTM_TOM0_CH15_CTRL |= (1<<SL);


     GTM_TOM0_CH1_CTRL &= ~((0x7)<<CLK_SRC_SR);
     GTM_TOM0_CH1_CTRL |=  (1 <<CLK_SRC_SR);
     GTM_TOM0_CH1_SR0 = 12500 -1 ;
     GTM_TOM0_CH1_SR1 = 0 ; //DUTYCYLE = 0
     //GTM_TOM0_CH1_SR1 = 6250 -1 ; //DUTICYCLE = 50
     //GTM_TOM0_CH1_SR1 = 12500 -1 ; // DUTYCYCLE = 100


     GTM_TOM0_CH2_CTRL &= ~((0x7)<<CLK_SRC_SR);
     GTM_TOM0_CH2_CTRL |=  (1 <<CLK_SRC_SR);
     GTM_TOM0_CH2_SR0 = 12500 -1 ;
     GTM_TOM0_CH2_SR1 = 0 ; //DUTYCYLE = 0
     //GTM_TOM0_CH2_SR1 = 6250 -1 ; //DUTICYCLE = 50
     //GTM_TOM0_CH2_SR1 = 12500 -1 ; // DUTYCYCLE = 100

     GTM_TOM0_CH3_CTRL &= ~((0x7)<<CLK_SRC_SR);
     GTM_TOM0_CH3_CTRL |=  (1 <<CLK_SRC_SR);
     GTM_TOM0_CH3_SR0 = 12500 -1 ;
     GTM_TOM0_CH3_SR1 = 0 ; //DUTYCYLE = 0
     //GTM_TOM0_CH3_SR1 = 6250 -1 ; //DUTICYCLE = 50
     //GTM_TOM0_CH3_SR1 = 12500 -1 ; // DUTYCYCLE = 100

     GTM_TOM0_CH15_CTRL &= ~((0x7)<<CLK_SRC_SR);
     GTM_TOM0_CH15_CTRL |=  (1 <<CLK_SRC_SR);
     GTM_TOM0_CH15_SR0 = 12500 -1 ;
     GTM_TOM0_CH15_SR1 = 0 ; //DUTYCYLE = 0
     //GTM_TOM0_CH15_SR1 = 6250 -1 ; //DUTICYCLE = 50
     //GTM_TOM0_CH15_SR1 = 12500 -1 ; // DUTYCYCLE = 100


     //GTM_TOUTSEL6 &= ~((0x3)<<SEL7);
     GTM_TOUTSEL6 &= ~((0x3)<<SEL8);

     GTM_TOUTSEL0 &= ~((0x3)<<SEL7); //red
     GTM_TOUTSEL6 &= ~((0x3)<<SEL11); //green
     GTM_TOUTSEL6 &= ~((0x3)<<SEL9); //blue

     GTM_TOM0_TGC0_GLB_CTRL |=(1<<HOST_TRIG);
     GTM_TOM0_TGC1_GLB_CTRL |=(1<<HOST_TRIG);

 }

 void init_VADC(void)
 {
     /* VADC Enable */
     /* Password Access to unlock WDTCPU0CON0 */
     SCU_WDTCPU0CON0 = ((SCU_WDTCPU0CON0 ^ 0xFC) & ~(1 << LCK)) | (1 << ENDINIT);
     while((SCU_WDTCPU0CON0 & (1<< LCK)) != 0);

     // Modify Aceess to clear ENDINIT bit
     SCU_WDTCPU0CON0 = ((SCU_WDTCPU0CON0 ^ 0xFC) | (1 << LCK)) & ~ (1 << ENDINIT);
     while((SCU_WDTCPU0CON0 &(1 << LCK)) == 0);

     VADC_CLC &= ~(1 << DISR);     // Enable VADC Module

     /* Password Access to unlock WDTCPU0CON0 */
     SCU_WDTCPU0CON0 = ((SCU_WDTCPU0CON0 ^ 0xFC) & ~(1 << LCK)) | (1 << ENDINIT);
     while((SCU_WDTCPU0CON0 & (1<< LCK)) != 0);

     // Modify Aceess to set ENDINIT bit
     SCU_WDTCPU0CON0 = ((SCU_WDTCPU0CON0 ^ 0xFC) | (1 << LCK)) | (1 << ENDINIT);
     while((SCU_WDTCPU0CON0 &(1 << LCK)) == 0);

     while((VADC_CLC & (1<<DISS)) !=0);      //Wait until module is enabled

     VADC_G4ARBPR |= ((0x3) << PRIO0);      // Highest Priority for request source 0
     VADC_G4ARBPR &= ~(1 << CSM0);          // Conversion Start Mode : Wait-for-start mode
     VADC_G4ARBPR |= (1 << ASEN0);          // Arbitration Source Input 0 Enable


     VADC_G4QMR0 &= ~((0x3) << ENGT);       //Enable Conversion Requests
     VADC_G4QMR0 |= ((0x1) << ENGT);

     VADC_G4QMR0 |= ( 1 << FLUSH);          //Clear all Queue Entries

     VADC_G4ARBCFG |= ((0x3) << ANONC);     //Analog Converter : Normal Operation

     VADC_G4ICLASS0 &= ~((0x7) << CMS);     // Group-specific Class 0
                                            // Conversion Mode : Standard Conversion (12-bit)
     VADC_G4ICLASS0 |= ((0x0) << CMS);      // 0x2 : 8bit 0x0 : 12bit

     VADC_G4ICLASS0 &= ~((0x1F) << STCS);     // sampling time

 //    VADC_G4ICLASS0 |= ((0x1F) << STCS);      //

     /*VADC Group 4 CH 7 Setting */
     //VADC_G4CHCTR7 &= ~(1 << RESPOS);        // Read Results Left-aligned
     VADC_G4CHCTR7 |= (1 << RESPOS);        // Read Results Right-aligned
     VADC_G4CHCTR7 &= ~((0xF) << RESREG);   // Store result in Group Result Register G4RES1
 //    VADC_G4CHCTR7 |= (1 << RESREG);
     VADC_G4CHCTR7 |= ((0x3) << RESREG);
     VADC_G4CHCTR7 &= ~((0x3) << ICLSEL);   // Use Group-specific Class 0

 }



 void VADC_startConversion(void)
 {
     /*No fill and Start Queue*/
     VADC_G4QINR0 &= ~(0x1F);                // Request Channel Number : 7
     VADC_G4QINR0 |= (0x07);

     VADC_G4QINR0 &= ~(1 << RF);             // No fill : it is converted once

     VADC_G4QMR0 |= (1 << TREV);             // Gernerate a Trigger event

 }



 unsigned int VADC_readResult(void)
 {
     unsigned int result;

     //while((VADC_G4RES1 & (1 << VF))==0);         // Wait until New result Available

     //result = (VADC_G4RES1 & ((0xFFFF)<< RESULT));  // Read Result

     while((VADC_G4RES3 & (1 << VF))==0);         // Wait until New result Available

     result = (VADC_G4RES3 & ((0x0FFF)<< RESULT));  // Read Result

     return result;
 }


IfxCpu_syncEvent g_cpuSyncEvent = 0;




int core0_main(void)
{
    IfxCpu_enableInterrupts();

    /* !!WATCHDOG0 AND SAFETY WATCHDOG ARE DISABLED HERE!!
     * Enable the watchdogs and service them periodically if it is required
     */
    IfxScuWdt_disableCpuWatchdog(IfxScuWdt_getCpuWatchdogPassword());
    IfxScuWdt_disableSafetyWatchdog(IfxScuWdt_getSafetyWatchdogPassword());

    /* Wait for CPU sync event */
    IfxCpu_emitEvent(&g_cpuSyncEvent);
    IfxCpu_waitEvent(&g_cpuSyncEvent, 1);

    init_RGBLED();
    init_LED();
    init_GTM_TOM0_PWM();
    init_VADC();
    unsigned int adcResult;


    while(1)
    {

        VADC_startConversion();

        adcResult = VADC_readResult();


        // 4095 : 100%   , 0 : 0%
        if(adcResult>=4095)
        {
        GTM_TOM0_CH1_SR1 = 12500 -1;
        GTM_TOM0_CH2_SR1 =0;
        GTM_TOM0_CH3_SR1 = 0;
        GTM_TOM0_CH15_SR1 = 12500 -1;
        }

        else if(adcResult>=2730)
        {
        GTM_TOM0_CH1_SR1 = (adcResult - 2730) * 9;

        GTM_TOM0_CH2_SR1 = 0;
        GTM_TOM0_CH3_SR1 = -(adcResult - 4095)*9;
        GTM_TOM0_CH15_SR1 = (adcResult - 2730) * 9;
        }
        else if(adcResult>=1365)
        {

        GTM_TOM0_CH2_SR1 =  - (adcResult-2730)*9;
        GTM_TOM0_CH3_SR1 = (adcResult - 1365) * 9;
        GTM_TOM0_CH15_SR1 = 0;
        }
        else
        {
        GTM_TOM0_CH1_SR1 = -(adcResult - 1365)*9;

        GTM_TOM0_CH2_SR1 = adcResult * 9;
        GTM_TOM0_CH3_SR1 = 0;
        GTM_TOM0_CH15_SR1 = -(adcResult - 1365)*9;
        }

        // RED    D9    : Port2  Pin7 TOUT7  TOUTSEL0 SEL7    TOM0_15
        // GREEN  D10   : Port10 Pin5 TOUT107 TOUTSEL6 SEL11  TOM0_2
        // BLUE   D11   : Port10 Pin3 TOUT105 TOUTSEL6 SEL9   TOM0_3


    }
    return (1);
}

